{
  "language": "Solidity",
  "sources": {
    "src/contracts/AdManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./interface/IAdManager.sol\";\n\ncontract AdManager is IAdManager {\n    // struct 광고정보\n    struct adInfo {\n        uint256 adId;\n        address publisherAddress;\n        string publisherIpfs;\n        string publisherProject;\n        string network;\n        string location;\n        uint256 x_size;\n        uint256 y_size;\n        uint256 mindate;\n        uint256 maxdate;\n        uint256 dau;\n        uint256 minprice;\n    }\n\n    struct clientInfo {\n        uint256 adId;\n        address clientAddress;\n        string clientIpfs;\n        string clientProject;\n        string clientDescription;\n        uint256 paidETH;\n    }\n\n    struct adStatus {\n        uint256 adId;\n        address clientAddress;\n        string clientIpfs;\n        uint256 adPrice;\n        uint256 startTime;\n        uint256 guaranteeTime;\n        uint256 expireTime;\n    }\n    address public owner;\n\n    mapping(uint256 => adInfo) public ads; // adId => adInfo\n    uint256 private _idCounter;\n\n    mapping(uint256 => clientInfo[]) public clientList; // adId => clientInfo[]\n\n    mapping(uint256 => adStatus) public adOn; // adId => adStatus\n\n    mapping(address => bool) public isPublisher;\n    mapping(address => uint256[]) public publisherId;\n\n    event AdRegistered(\n        uint256 adId,\n        address publisher,\n        string ipfs,\n        string project,\n        string network,\n        string location,\n        uint256 x_size,\n        uint256 y_size,\n        uint256 mindate,\n        uint256 maxdate,\n        uint256 dau,\n        uint256 minprice\n    );\n\n    event ClientRegistered(\n        address client,\n        uint256 adId,\n        string clientIpfs,\n        string clientProject,\n        string clientDescription,\n        uint256 paidETH\n    );\n\n    event ClientAllowed(uint256 adId, address clientAddress);\n\n    event ClientDenied(uint256 adId, address clientAddress);\n\n    event AdPurchased(\n        uint256 adId,\n        address clientAddress,\n        string clientIpfs,\n        uint256 price,\n        uint256 startTime,\n        uint256 guaranteeTime,\n        uint256 expireTime\n    );\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Owner only\");\n        _;\n    }\n\n    modifier onlyPublisher() {\n        require(isPublisher[msg.sender], \"Publisher only\");\n        _;\n    }\n\n    // constructor?\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function setPublisher(address _publisher, bool _isActive) public {\n        isPublisher[_publisher] = _isActive;\n    }\n\n    // 관리자가 form 정보 받아서 광고 추가 event 반환\n    function registerAd(\n        string memory _publisherIpfs,\n        string memory _publisherProject,\n        string memory _network,\n        string memory _location,\n        uint256 _x_size,\n        uint256 _y_size,\n        uint256 _mindate,\n        uint256 _maxdate,\n        uint256 _dau,\n        uint256 _minprice\n    ) public {\n        uint256 newId = _idCounter;\n\n        ads[newId] = adInfo({\n            adId: newId,\n            publisherAddress: msg.sender,\n            publisherIpfs: _publisherIpfs,\n            publisherProject: _publisherProject,\n            network: _network,\n            location: _location,\n            x_size: _x_size,\n            y_size: _y_size,\n            mindate: _mindate,\n            maxdate: _maxdate,\n            dau: _dau,\n            minprice: _minprice\n        });\n        setPublisher(msg.sender, true);\n        publisherId[msg.sender].push(newId);\n\n        // emit\n        emit AdRegistered(\n            ads[newId].adId,\n            ads[newId].publisherAddress,\n            ads[newId].publisherIpfs,\n            ads[newId].publisherProject,\n            ads[newId].network,\n            ads[newId].location,\n            ads[newId].x_size,\n            ads[newId].y_size,\n            ads[newId].mindate,\n            ads[newId].maxdate,\n            ads[newId].dau,\n            ads[newId].minprice\n        );\n\n        _idCounter++;\n    }\n\n    // 만료되거나, 광고를 내릴 일 있을 때.\n    // function manageAd() public onlyOwner {}\n\n    // purchase - 1\n    function registerClient(\n        uint256 _adId,\n        string memory _clientIpfs,\n        string memory _clientProject,\n        string memory _clientDescription\n    ) public payable {\n        adInfo memory ad = ads[_adId];\n        require(msg.value >= ad.minprice, \"Not enough ETH sent\");\n\n        uint256 excess = msg.value - ad.minprice;\n        if (excess > 0) {\n            payable(msg.sender).transfer(excess);\n        }\n\n        clientInfo memory newClient = clientInfo({\n            adId: _adId,\n            clientAddress: msg.sender,\n            clientIpfs: _clientIpfs,\n            clientProject: _clientProject,\n            clientDescription: _clientDescription,\n            paidETH: msg.value - excess\n        });\n\n        clientList[_adId].push(newClient);\n\n        emit ClientRegistered(\n            newClient.clientAddress,\n            newClient.adId,\n            newClient.clientIpfs,\n            newClient.clientProject,\n            newClient.clientDescription,\n            newClient.paidETH\n        );\n    }\n\n    // purchase - 3\n    // 보다 높은 가격에 해당 광고 입찰\n    function registerOverClient(\n        uint256 _adId,\n        string memory _clientIpfs,\n        string memory _clientProject,\n        string memory _clientDescription\n    ) public payable {\n        adInfo memory ad = ads[_adId];\n        adStatus memory currentAd = adOn[_adId];\n\n        uint256 currentTime = block.timestamp;\n\n        require(currentAd.clientAddress != address(0), \"Ad doesn't exist\");\n        // require mindate 이후\n        require(currentAd.guaranteeTime <= currentTime, \"Minimum guaranteed time hasn't passed\");\n        // require maxdate 지나지 않음\n        require(currentAd.expireTime >= currentTime, \"Ad already expired, call registerClient function\");\n        // require 현재 가격 n% 이상\n        require((currentAd.adPrice * 110) / 100 <= msg.value, \"Should register more value than +10%\");\n\n        // 새 AdInfo 저장\n        clientInfo memory newClient = clientInfo({\n            adId: _adId,\n            clientAddress: msg.sender,\n            clientIpfs: _clientIpfs,\n            clientProject: _clientProject,\n            clientDescription: _clientDescription,\n            paidETH: msg.value\n        });\n\n        clientList[_adId].push(newClient);\n\n        emit ClientRegistered(\n            newClient.clientAddress,\n            newClient.adId,\n            newClient.clientIpfs,\n            newClient.clientProject,\n            newClient.clientDescription,\n            newClient.paidETH\n        );\n    }\n\n    // purchase - 2\n    function allowAd(uint256 _adId, address _clientAddress) public onlyPublisher {\n        adInfo memory ad = ads[_adId];\n        clientInfo[] storage clients = clientList[_adId];\n\n        // require publisher = 해당 광고 id의 publisher\n        require(ad.publisherAddress == msg.sender, \"Not the publisher\");\n\n        uint256 currentTime = block.timestamp;\n        uint256 mindate = currentTime + ad.mindate * 1 days;\n        uint256 maxdate = currentTime + ad.maxdate * 1 days;\n\n        for (uint256 i = 0; i < clients.length; ) {\n            if (clients[i].clientAddress == _clientAddress) {\n                clientInfo memory client = clients[i];\n\n                // transfer ETH to publisher\n                payable(msg.sender).transfer(client.paidETH);\n\n                // turn on the Ad (adStatus)\n                adOn[_adId] = adStatus({\n                    adId: _adId,\n                    clientAddress: client.clientAddress,\n                    clientIpfs: client.clientIpfs,\n                    adPrice: client.paidETH,\n                    startTime: currentTime,\n                    guaranteeTime: mindate,\n                    expireTime: maxdate\n                });\n                // emit ClientAllowed(_adId, _clientAddress);\n                emit AdPurchased(\n                    _adId,\n                    clients[i].clientAddress,\n                    clients[i].clientIpfs,\n                    ad.minprice,\n                    currentTime,\n                    mindate,\n                    maxdate\n                );\n                i++;\n            } else {\n                // 반환 other ETHs\n                payable(clients[i].clientAddress).transfer(clients[i].paidETH);\n                clients[i] = clients[clients.length - 1];\n                clients.pop();\n\n                continue;\n            }\n        }\n        return;\n        // revert(\"Client not found\");\n    }\n\n    function allowOverAd(uint256 _adId, address _clientAddress) public onlyPublisher {\n        adInfo memory ad = ads[_adId];\n        adStatus memory currentAd = adOn[_adId];\n        clientInfo[] storage clients = clientList[_adId];\n\n        // require publisher = 해당 광고 id의 publisher\n        require(ad.publisherAddress == msg.sender, \"Not the publisher\");\n        require(currentAd.clientAddress != address(0), \"Ad doesn't exist\");\n\n        uint256 currentTime = block.timestamp;\n        uint256 mindate = currentTime + ad.mindate * 1 days;\n        uint256 maxdate = currentTime + ad.maxdate * 1 days;\n\n        for (uint256 i = 0; i < clients.length; ) {\n            if (clients[i].clientAddress == _clientAddress) {\n                clientInfo memory client = clients[i];\n\n                // transfer ETH to publisher\n                payable(msg.sender).transfer(client.paidETH);\n\n                // turn on the Ad (adStatus)\n                adOn[_adId] = adStatus({\n                    adId: _adId,\n                    clientAddress: client.clientAddress,\n                    clientIpfs: client.clientIpfs,\n                    adPrice: client.paidETH,\n                    startTime: currentTime,\n                    guaranteeTime: mindate,\n                    expireTime: maxdate\n                });\n\n                emit AdPurchased(\n                    _adId,\n                    clients[i].clientAddress,\n                    clients[i].clientIpfs,\n                    ad.minprice,\n                    currentTime,\n                    mindate,\n                    maxdate\n                );\n                i++;\n            } else {\n                if (clients[i].clientAddress == currentAd.clientAddress) {\n                    payable(currentAd.clientAddress).transfer(\n                        currentAd.adPrice *\n                            ((currentTime - currentAd.startTime) / (currentAd.expireTime - currentAd.startTime))\n                    );\n                } else {\n                    payable(clients[i].clientAddress).transfer(clients[i].paidETH);\n                }\n                clients[i] = clients[clients.length - 1];\n                clients.pop();\n\n                continue;\n            }\n        }\n        return;\n    }\n\n    // 모든 광고 정보\n    function getAllAdInfo() public view returns (adInfo[] memory) {\n        adInfo[] memory allAds = new adInfo[](_idCounter);\n\n        for (uint256 i = 0; i < _idCounter; i++) {\n            allAds[i] = ads[i];\n        }\n\n        return allAds;\n    }\n\n    // 특정 광고 정보\n    function getAdInfo(uint256 _adId) public view returns (adInfo memory) {\n        return ads[_adId];\n    }\n\n    // 특정 광고의 입찰 client 정보\n    function getClientInfo(uint256 _adId) public view returns (clientInfo[] memory) {\n        return clientList[_adId];\n    }\n\n    // 해당 사용자가 보유한 모든 광고의 입찰 client 정보\n    function getClientInfoByPublisher() public view returns (clientInfo[] memory) {\n        uint256[] memory adIds = publisherId[msg.sender];\n        clientInfo[] memory allClients = new clientInfo[](adIds.length);\n\n        for (uint256 i = 0; i < adIds.length; i++) {\n            allClients[i] = clientList[adIds[i]][i];\n        }\n\n        return allClients;\n    }\n\n    // 특정 광고의 현재 구독 상태\n    function getAdStatus(uint256 _adId) public view returns (adStatus memory) {\n        return adOn[_adId];\n    }\n}\n"
    },
    "src/contracts/interface/IAdManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ninterface IAdManager {\n    // function 광고등록(관리자)\n    // function addAd() external {}\n    // function 광고관리(관리자)\n    // function buyAd\n    // function buyOverAd\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}